---
description:
globs: *.spec.ts
alwaysApply: false
---
# Testing Guidelines

## Rationale

This rule ensures tests follow consistent guidelines, improving code quality and making it easier to write reliable, meaningful tests. Standardized practices also help reduce bugs and simplify maintenance.

---

## Test Types

### Unit Tests

#### Purpose

Validate logic in isolation, with no side effects or framework dependencies. These tests should cover:

- Aggregate roots, entities, value objects and exceptions in the domain
- Command and query handlers, with repositories mocked using jest.Mocked.

#### Constraints

- Test files should follow `*.spec.ts` naming convention
- Must not rely on NestJS, decorators, or framework-level helpers (only jest.Mocked is allowed)
- Leverage ObjectMother to create instances of aggregated
- Use the `faker` library to generate realistic and varied test values
- One `describe` block per unit (e.g., per handler or aggregate)
- Mocks must simulate meaningful domain behaviors (not just dummy data)
- Prefer using the named constructor `create` over `new` unless it's necessary.
- Prefer using domain methods (e.g., entity methods) over directly manipulating primitives
  - Treat entities and value objects as first-class citizens
  - Avoid setting internal state directly — test through commands or method calls that reflect domain behavior
- Aggregate roots and value objects should have the following describes:
  - Creation
  - Serialization
  - Comparison
  - Interaction

#### Structure

- Use `Given/When/Then` format
- Always test in the following order:
  1. Errors (e.g., domain violations, missing entities)
  2. Edge cases (e.g., boundary values)
  3. Happy paths

#### Examples

An example unit test for the User aggregate root:
```ts
describe('User', () => {
  it('can be renamed', () => {
    const user = UserObjectMother.create();
    const accountId = user.getAccountId();
    const nickname = new StringValueObject(faker.person.firstName());
    repository.find.mockResolvedValue(user);

    const newNickname = new StringValueObject(faker.person.firstName());
    user.rename(newNickname);

    expect(user).toBeDefined();
    expect(user).toBeInstanceOf(User);
    expect(user.getId()).toBe(id);
    expect(user.getNickname().equals(newNickname)).toBe(true);
  });
});
```

An example unit test for the update per command use case
```ts
describe('UpdatePetCommandHandler', () => {
  it('should update only name when only name is provided', async () => {
    const pet = PetObjectMother.create();
    repository.find.mockResolvedValue(pet);
    const newName = faker.animal.cat();
    const command = new UpdatePetCommand(pet.getId().toString(), newName);
    const saveSpy = jest.spyOn(repository, 'save');
    const findSpy = jest.spyOn(repository, 'find');

    await commandHandler.handle(command);

    expect(findSpy).toHaveBeenCalledWith(pet.getId());
    expect(saveSpy).toHaveBeenCalledWith({
      ...pet,
      name: new StringValueObject(newName),
    });
  });

})
```

## Consistency Rules

### Order of Assertions

- Always test in the following order:
  1. Errors
  2. Edge cases
  3. Happy paths

### Behavior Over Data

- Focus tests on **domain behavior**, not raw data
- Avoid testing implementation details or direct property values unless they represent domain outcomes
- Prefer:
  ✅ `expect(user.isActive()).toBe(true)`
  ❌ `expect(user.status).toBe('ACTIVE')` (unless status is a core domain concept)
- Use domain language in test descriptions and assertions
- Test names should be descriptive, not generic
  ✅ `should throw when user already exists`
  ❌ `should throw`
